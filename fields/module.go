// Copyright 2021 Linka Cloud  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package fields

import (
	"regexp"
	"strings"
	"text/template"

	golint "github.com/alta/protopatch/lint"
	"github.com/alta/protopatch/patch/gopb"
	"github.com/golang/protobuf/proto"
	pgs "github.com/lyft/protoc-gen-star"
	pgsgo "github.com/lyft/protoc-gen-star/lang/go"
)

type Extension interface {
	pgs.Node
	Extension(desc *proto.ExtensionDesc, ext interface{}) (ok bool, err error)
	File() pgs.File
}

type Parent interface {
	pgs.Node
}

func Module() *goFields {
	return &goFields{
		ModuleBase: &pgs.ModuleBase{},
	}
}

type goFields struct {
	*pgs.ModuleBase
	ctx  pgsgo.Context
	tpl  *template.Template
	skip *regexp.Regexp
}

func (p *goFields) Name() string {
	return "go-fields"
}

func maybeRename(ctx pgsgo.Context, n Extension) pgs.Name {
	var field gopb.Options
	if ok, _ := n.Extension(gopb.E_Field, &field); ok && field.Name != nil {
		return pgs.Name(field.GetName())
	}
	var lint gopb.LintOptions
	if ok, _ := n.File().Extension(gopb.E_Lint, &lint); !ok {
		return ctx.Name(n)
	}
	var ok bool
	switch n.(type) {
	case pgs.Field:
		ok = lint.GetAll() || lint.GetFields()
	case pgs.Message:
		ok = lint.GetAll() || lint.GetMessages()
	case pgs.Enum:
		ok = lint.GetAll() || lint.GetEnums()
	}
	if ok {
		return pgs.Name(golint.Name(ctx.Name(n).String(), lint.InitialismsMap()))
	}
	return ctx.Name(n)
}

func (p *goFields) InitContext(c pgs.BuildContext) {
	p.ModuleBase.InitContext(c)
	p.ctx = pgsgo.InitContext(c.Parameters())
	if v, ok := c.Parameters()["skip"]; ok {
		var err error
		p.skip, err = regexp.Compile(v)
		if err != nil {
			p.Failf("invalid skip regex: %v", err)
		}
	}

	tpl := template.New("fields").Funcs(map[string]interface{}{
		"package": p.ctx.PackageName,
		"name": func(node pgs.Node) pgs.Name {
			if n, ok := any(node).(Extension); ok {
				return maybeRename(p.ctx, n)
			}
			return p.ctx.Name(node)
		},
		"comment": func(s string) string {
			var out string
			parts := strings.Split(s, "\n")
			for i, v := range parts {
				if i == len(parts)-1 && v == "" {
					return out
				}
				out += "//" + v + "\n"
			}
			return out
		},
		"filter": func(ms []pgs.Message) []pgs.Message {
			if p.skip == nil {
				return ms
			}
			var out []pgs.Message
			for _, v := range ms {
				if p.skip.MatchString(v.Name().String()) {
					continue
				}
				out = append(out, v)
			}
			return out
		},
	})
	p.tpl = template.Must(tpl.Parse(fieldsTpl))
}

func (p *goFields) Execute(targets map[string]pgs.File, _ map[string]pgs.Package) []pgs.Artifact {
	for _, f := range targets {
		p.generate(f)
	}
	return p.Artifacts()
}

func (p *goFields) generate(f pgs.File) {
	if len(f.Messages()) == 0 && len(f.Services()) == 0 {
		return
	}
	name := p.ctx.OutputPath(f).SetExt(".fields.go")
	p.AddGeneratorTemplateFile(name.String(), p.tpl, f)
}

const fieldsTpl = `{{ comment .SyntaxSourceCodeInfo.LeadingComments }}
{{ range .SyntaxSourceCodeInfo.LeadingDetachedComments }}
{{ comment . }}
{{ end }}
// Code generated by protoc-gen-defaults. DO NOT EDIT.

package {{ package . }}

{{ $file := . }}
{{ range (filter .AllMessages) }}

var {{ name . }}Fields = struct {
	{{- range .Fields }}
	{{ name . }} string
	{{- end }}
}{
	{{- range .Fields }}
	{{ name . }}: "{{ .Name }}",
	{{- end }}
}

{{ end }}
`
